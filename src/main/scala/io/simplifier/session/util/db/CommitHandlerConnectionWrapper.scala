package io.simplifier.session.util.db

import io.simplifier.pluginbase.util.logging.Logging

import java.sql.{Blob, CallableStatement, Clob, Connection, DatabaseMetaData, NClob, PreparedStatement, SQLWarning, SQLXML, Savepoint, Statement, Struct}
import java.util.Properties
import java.{sql, util}
import java.util.concurrent.Executor
import org.squeryl.Session

import scala.util.Try
import scala.util.control.NonFatal



class CommitHandlerConnectionWrapper(val wrapped: Connection) extends Connection with Logging {

  @volatile
  private var handlers: Seq[CommitHandler] = Seq.empty

  /**
    * Add Commit handler to list
    * @param handler handler object
    * @param skipIfAlreadyRegistered if true, the handler will only be added, if it is not already in the list of registered handlers
    */
  def addHandler(handler: CommitHandler, skipIfAlreadyRegistered: Boolean): Unit = {
    if (!skipIfAlreadyRegistered || !handlers.contains(handler)) {
      handlers :+= handler
    }
  }

  private def executeCommitHandlers(): Unit = {
    handlers.foreach {
      handler =>
        Try {
          handler.handleConnectionCommit()
        } recover {
          case NonFatal(e) =>
            logger.warn("Error executing connection commit handler", e)
        }
    }
  }

  override def commit(): Unit = {
    wrapped.commit()
    // if no exception occurred here, the commit was finished successfully
    executeCommitHandlers()
  }

  override def unwrap[T](iface: Class[T]): T = {
    if (iface == classOf[CommitHandlerConnectionWrapper])
      this.asInstanceOf[T]
    else
      wrapped.unwrap(iface)
  }

  override def isWrapperFor(iface: Class[_]): Boolean = {
    if (iface == classOf[CommitHandlerConnectionWrapper])
      true
    else
      wrapped.isWrapperFor(iface)
  }

  /*
   * Wrapped methods
   */

  override def getHoldability: Int = wrapped.getHoldability

  override def setCatalog(catalog: String): Unit = wrapped.setCatalog(catalog)

  override def setHoldability(holdability: Int): Unit = wrapped.setHoldability(holdability)

  override def prepareStatement(sql: String): PreparedStatement = wrapped.prepareStatement(sql)

  override def prepareStatement(sql: String, resultSetType: Int, resultSetConcurrency: Int): PreparedStatement =
    wrapped.prepareStatement(sql, resultSetType, resultSetConcurrency)

  override def prepareStatement(sql: String, resultSetType: Int, resultSetConcurrency: Int, resultSetHoldability: Int): PreparedStatement =
    wrapped.prepareStatement(sql, resultSetType, resultSetConcurrency, resultSetHoldability)

  override def prepareStatement(sql: String, autoGeneratedKeys: Int): PreparedStatement =
    wrapped.prepareStatement(sql, autoGeneratedKeys)

  override def prepareStatement(sql: String, columnIndexes: Array[Int]): PreparedStatement =
    wrapped.prepareStatement(sql, columnIndexes)

  override def prepareStatement(sql: String, columnNames: Array[String]): PreparedStatement =
    wrapped.prepareStatement(sql, columnNames)

  override def createClob(): Clob = wrapped.createClob()

  override def setSchema(schema: String): Unit = wrapped.setSchema(schema)

  override def setClientInfo(name: String, value: String): Unit = wrapped.setClientInfo(name, value)

  override def setClientInfo(properties: Properties): Unit = wrapped.setClientInfo(properties)

  override def createSQLXML(): SQLXML = wrapped.createSQLXML()

  override def getCatalog: String = wrapped.getCatalog

  override def createBlob(): Blob = wrapped.createBlob()

  override def createStatement(): Statement = wrapped.createStatement()

  override def createStatement(resultSetType: Int, resultSetConcurrency: Int): Statement =
    wrapped.createStatement(resultSetType, resultSetConcurrency)

  override def createStatement(resultSetType: Int, resultSetConcurrency: Int, resultSetHoldability: Int): Statement =
    wrapped.createStatement(resultSetType, resultSetConcurrency, resultSetHoldability)

  override def abort(executor: Executor): Unit = wrapped.abort(executor)

  override def setAutoCommit(autoCommit: Boolean): Unit = wrapped.setAutoCommit(autoCommit)

  override def getMetaData: DatabaseMetaData = wrapped.getMetaData

  override def setReadOnly(readOnly: Boolean): Unit = wrapped.setReadOnly(readOnly)

  override def prepareCall(sql: String): CallableStatement = wrapped.prepareCall(sql)

  override def prepareCall(sql: String, resultSetType: Int, resultSetConcurrency: Int): CallableStatement =
    wrapped.prepareCall(sql, resultSetType, resultSetConcurrency)

  override def prepareCall(sql: String, resultSetType: Int, resultSetConcurrency: Int, resultSetHoldability: Int): CallableStatement =
    wrapped.prepareCall(sql, resultSetType, resultSetConcurrency, resultSetHoldability)

  override def setTransactionIsolation(level: Int): Unit = wrapped.setTransactionIsolation(level)

  override def getWarnings: SQLWarning = wrapped.getWarnings

  override def releaseSavepoint(savepoint: Savepoint): Unit = wrapped.releaseSavepoint(savepoint)

  override def rollback(): Unit = wrapped.rollback()

  override def rollback(savepoint: Savepoint): Unit = wrapped.rollback(savepoint)

  override def nativeSQL(sql: String): String = wrapped.nativeSQL(sql)

  override def isReadOnly: Boolean = wrapped.isReadOnly

  override def createArrayOf(typeName: String, elements: Array[AnyRef]): sql.Array = wrapped.createArrayOf(typeName, elements)

  override def setSavepoint(): Savepoint = wrapped.setSavepoint()

  override def setSavepoint(name: String): Savepoint = wrapped.setSavepoint(name)

  override def close(): Unit = wrapped.close()

  override def createNClob(): NClob = wrapped.createNClob()

  override def setNetworkTimeout(executor: Executor, milliseconds: Int): Unit = wrapped.setNetworkTimeout(executor, milliseconds)

  override def setTypeMap(map: util.Map[String, Class[_]]): Unit = wrapped.setTypeMap(map)

  override def isValid(timeout: Int): Boolean = wrapped.isValid(timeout)

  override def getAutoCommit: Boolean = wrapped.getAutoCommit

  override def clearWarnings(): Unit = wrapped.clearWarnings()

  override def getSchema: String = wrapped.getSchema

  override def getNetworkTimeout: Int = wrapped.getNetworkTimeout

  override def isClosed: Boolean = wrapped.isClosed

  override def getTransactionIsolation: Int = wrapped.getTransactionIsolation

  override def createStruct(typeName: String, attributes: Array[AnyRef]): Struct =  wrapped.createStruct(typeName, attributes)

  override def getClientInfo(name: String): String = wrapped.getClientInfo(name)

  override def getClientInfo: Properties = wrapped.getClientInfo

  override def getTypeMap: util.Map[String, Class[_]] = wrapped.getTypeMap

}

object CommitHandlerConnectionWrapper extends Logging {

  /**
    * Add Commit handler to connection in current session.
    * @param handler handler object
    * @param skipIfAlreadyRegistered if true, the handler will only be added, if it is not already in the list of registered handlers
    */
  def attachCommitHandler(handler: CommitHandler, skipIfAlreadyRegistered: Boolean): Unit = {
    if (Session.hasCurrentSession) {
      val con = Session.currentSession.connection
      if (con.isWrapperFor(classOf[CommitHandlerConnectionWrapper])) {
        con.unwrap(classOf[CommitHandlerConnectionWrapper]).addHandler(handler, skipIfAlreadyRegistered)
      } else {
        logger.warn("Connection is not of type CommitHandlerConnectionWrapper, but: " + con.getClass)
      }
    } else {
      logger.warn("Cannot attach commit handler outside of a transaction")
    }
  }

}
